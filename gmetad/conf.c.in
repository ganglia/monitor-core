#include <dotconf.h>
#include <string.h>
#include <gmetad.h>
#include <ganglia.h>
#include "conf.h"

/* Variables that get filled in by configuration file */
extern Source_t root;
extern hash_t *sources;

gmetad_config_t gmetad_config;

#define GANGLIA_HOSTNAME_LEN  128

static DOTCONF_CB(cb_gridname)
{
    gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
    debug_msg("Grid name %s", cmd->data.str);
    c->gridname = strdup(cmd->data.str);
    return NULL;
}

static DOTCONF_CB(cb_authority)
{
   /* See gmetad.h for why we record strings this way. */
    debug_msg("Grid authority %s", cmd->data.str);
    root.authority_ptr = 0;
    strcpy(root.strings, cmd->data.str);
    root.stringslen += strlen(root.strings) + 1;
    return NULL;
}

static DOTCONF_CB(cb_all_trusted)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("All hosts are trusted!");
   c->all_trusted = 1;
   return NULL;
}

static DOTCONF_CB(cb_trusted_hosts)
{
   int i,rv;
   llist_entry *le;
   struct sockaddr_in sa;
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;

   for (i = 0; i < cmd->arg_count; i++)
      {
         le = (llist_entry *)malloc(sizeof(llist_entry));
         rv = g_gethostbyname( cmd->data.list[i], &sa, NULL);
         if (!rv) {
            err_msg("Warning: we failed to resolve trusted host name %s", cmd->data.list[i]);
            continue;
         }
         le->val = (char*) malloc(GANGLIA_HOSTNAME_LEN);
         my_inet_ntop(AF_INET, &sa.sin_addr, le->val, GANGLIA_HOSTNAME_LEN);
         llist_add(&(c->trusted_hosts), le);
      }
   return NULL;
}

static DOTCONF_CB(cb_RRAs)
{
  int i;
  gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
  c->num_RRAs = cmd->arg_count;
  for(i = 0; i < c->num_RRAs; i++)
    {
      c->RRAs[i] = strdup(cmd->data.list[i]);
    }
  return NULL;
}

static DOTCONF_CB(cb_data_source)
{
   unsigned int i;
   data_source_list_t *dslist;
   datum_t key, val, *find;
   int rv=0;
   unsigned long step;
   unsigned int source_index=0;
   char *p, *str, *host, *port;
   char *endptr;
   struct sockaddr_in sa;
   g_inet6_addr ia;
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;

   source_index++;

   debug_msg("Datasource = [%s]", cmd->data.list[0]);

   dslist = (data_source_list_t *) malloc ( sizeof(data_source_list_t) );
   if(!dslist)
      {
         err_quit("Unable to malloc data source list");
      }

   dslist->name = strdup( cmd->data.list[0] );

  /* Set data source step (avg polling interval). Default is 15s.
   * Be careful of the case where the source is an ip address,
   * in which case endptr = '.'
   */
  i=1;
  step=strtoul(cmd->data.list[i], &endptr, 10);
   if (step && *endptr == '\0')
      {
         dslist->step = step;
         i++;
      }
   else
      dslist->step = 15;

   debug_msg("Polling interval for %s is %u sec.", dslist->name, dslist->step);
   c->shortest_step = dslist->step;

   dslist->sources = (g_inet6_addr **) malloc( (cmd->arg_count-i) * sizeof(g_inet6_addr *) );
   if (! dslist->sources )
      err_quit("Unable to malloc sources array");

   dslist->num_sources = 0;
   dslist->last_good_index = -1;

   for ( ; i< cmd->arg_count; i++)
      {
         str = cmd->data.list[i];

	p = strchr(str, '[');
        if (p != NULL)
            host = p + 1;
        else
            host = str;
        p = strchr(str, ']');
        if (p) {
            *p = '\0';
            if (*(p+1) == ':')
                port = p+2;
            else
                port = "8649";
        }
        else {
            p = strchr(host, ':');
            if (p) {
                if (p == strrchr(host, ':')) {
                    *p = '\0';
                    port = p+1;
                }
                else
                    port = "8649";
            }
            else
                port = "8649";
        }

	

        rv = g_getaddrinfo(host, port, &ia, NULL);
        if (rv) {
            err_msg("Warning: we failed to resolve data source name %s", cmd->data.list[i]);
            continue;
        }
        
        debug_msg("Trying to connect to %s:%s for [%s]", host, port, dslist->name);
        dslist->sources[dslist->num_sources] = (g_inet6_addr *)malloc(sizeof(g_inet6_addr));
        if (dslist->sources[dslist->num_sources] == NULL)
            err_quit("Unable to create inetaddr [%s:%s] and save it to [%s]", host, port, dslist->name);
        else {
            memcpy(dslist->sources[dslist->num_sources], &ia, sizeof(g_inet6_addr));
            dslist->num_sources++;
        }
      }

   key.data = cmd->data.list[0];
   key.size = strlen(key.data) + 1;

   val.data = &dslist;
   val.size = sizeof(dslist);

   find  = hash_insert( &key, &val, sources );
   if(!find)
         err_quit("Unable to insert list pointer into source hash\n");
   
   debug_msg("Data inserted for [%s] into sources hash", (const char *) key.data);
   return NULL;
}

static DOTCONF_CB(cb_debug_level)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   c->debug_level = cmd->data.value;
   debug_msg("Setting the debug level to %ld", cmd->data.value);
   return NULL;
}

static DOTCONF_CB(cb_xml_port)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Setting xml port to %ld", cmd->data.value);
   c->xml_port = cmd->data.value;
   return NULL;
}

static DOTCONF_CB(cb_interactive_port)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Setting interactive port to %ld", cmd->data.value);
   c->interactive_port = cmd->data.value;
   return NULL;
}

static DOTCONF_CB(cb_server_threads)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Setting number of xml server threads to %ld", cmd->data.value);
   c->server_threads = cmd->data.value;
   return NULL;
}

static DOTCONF_CB(cb_umask)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Setting umask to %.5lo & 07077", cmd->data.value);
   c->umask = cmd->data.value & 07077; /* protect owner permissions */
   return NULL;
}

static DOTCONF_CB(cb_rrd_rootdir)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Setting the RRD Rootdir to %s", cmd->data.str);
   c->rrd_rootdir = strdup (cmd->data.str);
   return NULL;
}

static DOTCONF_CB(cb_setuid_username)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Setting setuid username to %s", cmd->data.str);
   c->setuid_username = strdup(cmd->data.str);
   return NULL;
}

static DOTCONF_CB(cb_setuid)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   c->should_setuid = cmd->data.value;
   return NULL;
}

static DOTCONF_CB(cb_scalable)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Setting scalable = %s", cmd->data.str);
   if (!strcmp(cmd->data.str, "off"))
      c->scalable_mode = 0;
   return NULL;
}

static DOTCONF_CB(cb_write_rrds)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Setting write_rrds = %s", cmd->data.str);
   if (!strcmp(cmd->data.str, "off"))
       c->write_rrds = cmd->data.value;
   return NULL;
}

static DOTCONF_CB(cb_case_sensitive_hostnames)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   c->case_sensitive_hostnames = cmd->data.value;
   return NULL;
}

static DOTCONF_CB(cb_carbon_server)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Enabling Graphite proxy to %s", cmd->data.str);
   c->carbon_server = strdup (cmd->data.str);
   return NULL;
}

static DOTCONF_CB(cb_carbon_port)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Setting carbon port to %ld", cmd->data.value);
   c->carbon_port = cmd->data.value;
   return NULL;
}

static DOTCONF_CB(cb_carbon_protocol)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Setting carbon protocol to %s", cmd->data.str);
   c->carbon_protocol = strdup (cmd->data.str);
   return NULL;
}

static DOTCONF_CB(cb_carbon_timeout)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Setting carbon timeout to %ld", cmd->data.value);
   c->carbon_timeout = cmd->data.value;
   return NULL;
}

static DOTCONF_CB(cb_memcached_parameters)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Enabling memcached parameters to %s", cmd->data.str);
   c->memcached_parameters = strdup (cmd->data.str);
   return NULL;
}

static DOTCONF_CB(cb_memcached_include_cluster_in_key)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Setting memcached_include_cluster_in_key to %ld", cmd->data.value);
   c->memcached_include_cluster_in_key = cmd->data.value;
   return NULL;
}

static DOTCONF_CB(cb_graphite_prefix)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Enabling Graphite proxy to %s", cmd->data.str);
   c->graphite_prefix = strdup (cmd->data.str);
   return NULL;
}

static DOTCONF_CB(cb_graphite_path)
{
	gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
	debug_msg("Setting Graphite path to %s", cmd->data.str);
	c->graphite_path = strdup (cmd->data.str);
	return NULL;
} 

static DOTCONF_CB(cb_riemann_server)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Enabling Riemann forwarding to %s", cmd->data.str);
   c->riemann_server = strdup (cmd->data.str);
   return NULL;
}

static DOTCONF_CB(cb_riemann_port)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Setting Riemann port to %ld", cmd->data.value);
   c->riemann_port = cmd->data.value;
   return NULL;
}

static DOTCONF_CB(cb_riemann_protocol)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Setting Riemann protocol to %s", cmd->data.str);
   c->riemann_protocol = strdup (cmd->data.str);
   return NULL;
}

static DOTCONF_CB(cb_riemann_attributes)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Riemann key-value attributes %s", cmd->data.str);
   c->riemann_attributes = strdup (cmd->data.str);
   return NULL;
}

static DOTCONF_CB(cb_unsummarized_metrics)
{
   int i;
   llist_entry *le;
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;

   for (i = 0; i < cmd->arg_count; i++)
      {
         le = (llist_entry *)malloc(sizeof(llist_entry));
         le->val = strdup(cmd->data.list[i]);
         llist_add(&(c->unsummarized_metrics), le);
         debug_msg("Adding %s to unsummarized_metrics", (const char *) le->val);
      }
   return NULL;
}

static DOTCONF_CB(cb_unsummarized_sflow_vm_metrics)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   debug_msg("Setting unsummarized_sflow_vm_metrics = %ld", cmd->data.value);
   c->unsummarized_sflow_vm_metrics = cmd->data.value;
   return NULL;
}

static DOTCONF_CB(cb_summarized_metrics)
{
   int i;
   llist_entry *le;
   gmetad_config_t *c = cmd->option->info;

   for (i = 0; i < cmd->arg_count; i++)
      {
         le = malloc(sizeof(*le));
         le->val = strdup(cmd->data.list[i]);
         llist_add(&(c->summarized_metrics), le);
         debug_msg("Adding %s to summarized_metrics", (const char *)le->val);
      }
   return NULL;
}

static DOTCONF_CB(cb_rrdcached_address)
{
   gmetad_config_t *c = (gmetad_config_t*) cmd->option->info;
   char *ip, *tmp, *f;
   long port;

   f = tmp = strdup(cmd->data.str);
   if ((ip = strsep(&tmp, ":")) == NULL ||
       inet_pton(AF_INET, ip, &c->rrdcached_address.sin_addr) != 1)
      {
         err_quit("Expected IPv4 address in form a.b.c.d:port for "
                  "rrdcached_address, got %s\n", cmd->data.str);
      }
   port = strtol(tmp, NULL, 10);
   if ((port == 0 && errno == EINVAL) ||
       ((port == LONG_MIN || port == LONG_MAX) && errno == ERANGE) ||
       port < 0 || port > 65535)
      {
         err_quit("Expected IPv4 port within range; got %s\n", tmp);
      }

   c->rrdcached_address.sin_family = AF_INET;
   c->rrdcached_address.sin_port = htons(port);
   c->rrdcached_addrstr = strdup(cmd->data.str);
   free(f);

   return NULL;
}

static FUNC_ERRORHANDLER(errorhandler)
{
   err_quit("gmetad config file error: %s\n", msg);
   return 0;
}

static configoption_t gmetad_options[] =
   {
      {"data_source", ARG_LIST, cb_data_source, &gmetad_config, 0},
      {"gridname", ARG_STR, cb_gridname, &gmetad_config, 0},
      {"authority", ARG_STR, cb_authority, &gmetad_config, 0},
      {"trusted_hosts", ARG_LIST, cb_trusted_hosts, &gmetad_config, 0},
      {"all_trusted", ARG_INT, cb_all_trusted, &gmetad_config, 0},
      {"debug_level",  ARG_INT,  cb_debug_level, &gmetad_config, 0},
      {"xml_port",  ARG_INT, cb_xml_port, &gmetad_config, 0},
      {"interactive_port", ARG_INT, cb_interactive_port, &gmetad_config, 0},
      {"server_threads", ARG_INT, cb_server_threads, &gmetad_config, 0},
      {"umask", ARG_INT, cb_umask, &gmetad_config, 0},
      {"rrd_rootdir", ARG_STR, cb_rrd_rootdir, &gmetad_config, 0},
      {"rrdcached_address", ARG_STR, cb_rrdcached_address, &gmetad_config, 0},
      {"setuid", ARG_TOGGLE, cb_setuid, &gmetad_config, 0},
      {"setuid_username", ARG_STR, cb_setuid_username, &gmetad_config, 0},
      {"scalable", ARG_STR, cb_scalable, &gmetad_config, 0},
      {"write_rrds", ARG_STR, cb_write_rrds, &gmetad_config, 0},
      {"RRAs", ARG_LIST, cb_RRAs, &gmetad_config, 0},
      {"case_sensitive_hostnames", ARG_INT, cb_case_sensitive_hostnames, &gmetad_config, 0},
      {"carbon_server", ARG_STR, cb_carbon_server, &gmetad_config, 0},
      {"carbon_port", ARG_INT, cb_carbon_port, &gmetad_config, 0},
      {"carbon_protocol", ARG_STR, cb_carbon_protocol, &gmetad_config, 0},
      {"carbon_timeout", ARG_INT, cb_carbon_timeout, &gmetad_config, 0},
      {"memcached_parameters", ARG_STR, cb_memcached_parameters, &gmetad_config, 0},
      {"memcached_include_cluster_in_key", ARG_INT, cb_memcached_include_cluster_in_key, &gmetad_config, 0},
      {"graphite_prefix", ARG_STR, cb_graphite_prefix, &gmetad_config, 0},
      {"graphite_path", ARG_STR, cb_graphite_path, &gmetad_config, 0},
      {"riemann_server", ARG_STR, cb_riemann_server, &gmetad_config, 0},
      {"riemann_port", ARG_INT, cb_riemann_port, &gmetad_config, 0},
      {"riemann_protocol", ARG_STR, cb_riemann_protocol, &gmetad_config, 0},
      {"riemann_attributes", ARG_STR, cb_riemann_attributes, &gmetad_config, 0},
      {"unsummarized_metrics", ARG_LIST, cb_unsummarized_metrics, &gmetad_config, 0},
      {"unsummarized_sflow_vm_metrics", ARG_TOGGLE, cb_unsummarized_sflow_vm_metrics, &gmetad_config, 0},
      {"summarized_metrics", ARG_LIST, cb_summarized_metrics, &gmetad_config, 0},
      LAST_OPTION
   };

static void
set_defaults (gmetad_config_t *config)
{
   /* Gmetad defaults */
   config->gridname = "unspecified";
   config->xml_port = 8651;
   config->interactive_port = 8652;
   config->server_threads = 4;
   config->umask = 0;
   config->trusted_hosts = NULL;
   config->debug_level = 0;
   config->should_setuid = 1;
   config->setuid_username = "nobody";
   config->rrd_rootdir = "@varstatedir@/ganglia/rrds";
   config->rrdcached_addrstr = NULL;
   memset(&config->rrdcached_address, 0, sizeof (config->rrdcached_address));
   config->write_rrds = 1;
   config->scalable_mode = 1;
   config->all_trusted = 0;
   config->num_RRAs = 3;
   config->RRAs[0] = "RRA:AVERAGE:0.5:1:5856";
   config->RRAs[1] = "RRA:AVERAGE:0.5:4:20160";
   config->RRAs[2] = "RRA:AVERAGE:0.5:40:52704";
   config->case_sensitive_hostnames = 1;
   config->carbon_port = 2003;
   config->carbon_protocol = "tcp";
   config->carbon_timeout = 500;
   config->memcached_include_cluster_in_key = 0;
   config->riemann_port = 5555;
   config->riemann_protocol = "udp";
   config->riemann_attributes = NULL;
   config->unsummarized_metrics = NULL;
   config->unsummarized_sflow_vm_metrics = 0;
   config->summarized_metrics = NULL;
}

int
parse_config_file ( char *config_file )
{
   configfile_t *configfile;

   set_defaults(&gmetad_config);

   configfile = dotconf_create( config_file, gmetad_options, 0, CASE_INSENSITIVE );
   if (!configfile)
      {
         err_quit("Unable to open config file: %s\n", config_file);
      }

   configfile->errorhandler = (dotconf_errorhandler_t) errorhandler;

   if (dotconf_command_loop(configfile) == 0)
      {
         dotconf_cleanup(configfile);
         err_quit("dotconf_command_loop error");
      }
   return 0;
}

int
number_of_datasources ( char *config_file )
{
   int number_of_sources = 0;
   char buf[1024];
   configfile_t *configfile;

   configfile = dotconf_create( config_file, gmetad_options, 0, CASE_INSENSITIVE );
   if (!configfile) {
      err_quit("Unable to open config file: %s\n", config_file);
   }

   while (! dotconf_get_next_line( buf, 1024, configfile ))
      {
         if( strstr( buf, "data_source" ) && (buf[0] != '#') )
            {
               number_of_sources++;
            }
      }
   dotconf_cleanup(configfile);
   return number_of_sources;
}

